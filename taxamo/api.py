#!/usr/bin/env python
"""
Copyright 2014 Taxamo, Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at [apache.org/licenses/LICENSE-2.0](http://www.apache.org/licenses/LICENSE-2.0)

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

NOTE: This class is auto generated by the swagger code generator program. Do not edit the class manually.
"""
import sys
import os

from models import *


class ApiApi(object):

    def __init__(self, apiClient):
      self.apiClient = apiClient

    

    def createRefund(self, key, body, **kwargs):
        """Create a refund

        Args:
            key, str: Transaction key. (required)

            body, createRefundIn: Input (required)

            

        Returns: createRefundOut
        """

        allParams = ['key', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createRefund" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/refunds'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'createRefundOut')
        return responseObject
        

        

    def createPayment(self, key, body, **kwargs):
        """Register a payment

        Args:
            key, str: Transaction key. (required)

            body, createPaymentIn: Input (required)

            

        Returns: createPaymentOut
        """

        allParams = ['key', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createPayment" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/payments'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'createPaymentOut')
        return responseObject
        

        

    def listPayments(self, key, **kwargs):
        """List payments

        Args:
            limit, str: Max record count (no more than 100, defaults to 10). (optional)

            offset, str: How many records need to be skipped, defaults to 0. (optional)

            key, str: Transaction key. (required)

            

        Returns: listPaymentsOut
        """

        allParams = ['limit', 'offset', 'key']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listPayments" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/payments'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('limit' in params):
            queryParams['limit'] = self.apiClient.toPathValue(params['limit'])
        if ('offset' in params):
            queryParams['offset'] = self.apiClient.toPathValue(params['offset'])
        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'listPaymentsOut')
        return responseObject
        

        

    def capturePayment(self, key, **kwargs):
        """Capture payment

        Args:
            key, str: Transaction key. (required)

            

        Returns: capturePaymentOut
        """

        allParams = ['key']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method capturePayment" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/payments/capture'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'capturePaymentOut')
        return responseObject
        

        

    def createTransaction(self, body, **kwargs):
        """Store transaction

        Args:
            body, createTransactionIn: Input (required)

            

        Returns: createTransactionOut
        """

        allParams = ['body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createTransaction" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'createTransactionOut')
        return responseObject
        

        

    def getTransaction(self, key, **kwargs):
        """Retrieve transaction data.

        Args:
            key, str: Transaction key (required)

            

        Returns: getTransactionOut
        """

        allParams = ['key']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getTransaction" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getTransactionOut')
        return responseObject
        

        

    def updateTransaction(self, key, body, **kwargs):
        """Update transaction

        Args:
            key, str: Transaction key. (optional)

            body, updateTransactionIn: Input (required)

            

        Returns: updateTransactionOut
        """

        allParams = ['key', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method updateTransaction" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'PUT'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'updateTransactionOut')
        return responseObject
        

        

    def confirmTransaction(self, key, body, **kwargs):
        """Confirm transaction

        Args:
            key, str: Transaction key. (optional)

            body, confirmTransactionIn: Input (required)

            

        Returns: confirmTransactionOut
        """

        allParams = ['key', 'body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method confirmTransaction" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}/confirm'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'confirmTransactionOut')
        return responseObject
        

        

    def cancelTransaction(self, key, **kwargs):
        """Delete transaction

        Args:
            key, str: Transaction key (optional)

            

        Returns: cancelTransactionOut
        """

        allParams = ['key']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method cancelTransaction" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions/{key}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'DELETE'

        queryParams = {}
        headerParams = {}

        if ('key' in params):
            replacement = str(self.apiClient.toPathValue(params['key']))
            resourcePath = resourcePath.replace('{' + 'key' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'cancelTransactionOut')
        return responseObject
        

        

    def listTransactions(self, **kwargs):
        """Browse transactions

        Args:
            statuses, str: Comma separated list of of transaction statuses. (optional)

            sort_reverse, bool: If true, results are sorted in descending order. (optional)

            tax_country_code, str: Two letter ISO tax country code. (optional)

            order_date_from, str: Order date from in yyyy-MM-dd format. (optional)

            offset, integer: Offset (optional)

            filter_text, str: Filtering expression (optional)

            format, str: Output format - supports 'csv' value for this operation. (optional)

            order_date_to, str: Order date to in yyyy-MM-dd format. (optional)

            currency_code, str: Three letter ISO currency code. (optional)

            limit, integer: Limit (optional)

            

        Returns: listTransactionsOut
        """

        allParams = ['statuses', 'sort_reverse', 'tax_country_code', 'order_date_from', 'offset', 'filter_text', 'format', 'order_date_to', 'currency_code', 'limit']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method listTransactions" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/transactions'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('statuses' in params):
            queryParams['statuses'] = self.apiClient.toPathValue(params['statuses'])
        if ('sort_reverse' in params):
            queryParams['sort_reverse'] = self.apiClient.toPathValue(params['sort_reverse'])
        if ('tax_country_code' in params):
            queryParams['tax_country_code'] = self.apiClient.toPathValue(params['tax_country_code'])
        if ('order_date_from' in params):
            queryParams['order_date_from'] = self.apiClient.toPathValue(params['order_date_from'])
        if ('offset' in params):
            queryParams['offset'] = self.apiClient.toPathValue(params['offset'])
        if ('filter_text' in params):
            queryParams['filter_text'] = self.apiClient.toPathValue(params['filter_text'])
        if ('format' in params):
            queryParams['format'] = self.apiClient.toPathValue(params['format'])
        if ('order_date_to' in params):
            queryParams['order_date_to'] = self.apiClient.toPathValue(params['order_date_to'])
        if ('currency_code' in params):
            queryParams['currency_code'] = self.apiClient.toPathValue(params['currency_code'])
        if ('limit' in params):
            queryParams['limit'] = self.apiClient.toPathValue(params['limit'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'listTransactionsOut')
        return responseObject
        

        

    def calculateTax(self, body, **kwargs):
        """Calculate tax

        Args:
            body, calculateTaxIn: Input (required)

            

        Returns: calculateTaxOut
        """

        allParams = ['body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method calculateTax" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/tax/calculate'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'calculateTaxOut')
        return responseObject
        

        

    def calculateSimpleTax(self, currency_code, **kwargs):
        """Simple tax

        Args:
            buyer_credit_card_prefix, str: Buyer's credit card prefix. (optional)

            buyer_tax_number, str:  Buyer's tax number - EU VAT number for example. If using EU VAT number, it is possible to provide country code in it (e.g. IE1234567X) or simply use billing_country_code field for that. In the first case, if billing_country_code value was provided, it will be overwritten with country code value extracted from VAT number - but only if the VAT has been verified properly. (optional)

            product_type, str: Product type, according to dictionary /dictionaries/product_types.  (optional)

            force_country_code, str: Two-letter ISO country code, e.g. FR. Use it to force country code for tax calculation. (optional)

            quantity, number: Quantity Defaults to 1. (optional)

            unit_price, number: Unit price. (optional)

            total_amount, number: Total amount. Required if amount is not provided. (optional)

            tax_deducted, bool: True if the transaction deducted from tax and no tax is applied. Either set automatically when VAT number validates with VIES correctly, but can also be provided in manual mode. (optional)

            amount, number: Amount. Required if total amount is not provided. (optional)

            billing_country_code, str: Billing two letter ISO country code. (optional)

            currency_code, str: Currency code for transaction - e.g. EUR. (required)

            order_date, str: Order date in yyyy-MM-dd format, in merchant's timezone. If provided by the API caller, no timezone conversion is performed.
   Default value is current date and time. When using public token, the default value is used. (optional)

            

        Returns: calculateSimpleTaxOut
        """

        allParams = ['buyer_credit_card_prefix', 'buyer_tax_number', 'product_type', 'force_country_code', 'quantity', 'unit_price', 'total_amount', 'tax_deducted', 'amount', 'billing_country_code', 'currency_code', 'order_date']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method calculateSimpleTax" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/tax/calculate'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('buyer_credit_card_prefix' in params):
            queryParams['buyer_credit_card_prefix'] = self.apiClient.toPathValue(params['buyer_credit_card_prefix'])
        if ('buyer_tax_number' in params):
            queryParams['buyer_tax_number'] = self.apiClient.toPathValue(params['buyer_tax_number'])
        if ('product_type' in params):
            queryParams['product_type'] = self.apiClient.toPathValue(params['product_type'])
        if ('force_country_code' in params):
            queryParams['force_country_code'] = self.apiClient.toPathValue(params['force_country_code'])
        if ('quantity' in params):
            queryParams['quantity'] = self.apiClient.toPathValue(params['quantity'])
        if ('unit_price' in params):
            queryParams['unit_price'] = self.apiClient.toPathValue(params['unit_price'])
        if ('total_amount' in params):
            queryParams['total_amount'] = self.apiClient.toPathValue(params['total_amount'])
        if ('tax_deducted' in params):
            queryParams['tax_deducted'] = self.apiClient.toPathValue(params['tax_deducted'])
        if ('amount' in params):
            queryParams['amount'] = self.apiClient.toPathValue(params['amount'])
        if ('billing_country_code' in params):
            queryParams['billing_country_code'] = self.apiClient.toPathValue(params['billing_country_code'])
        if ('currency_code' in params):
            queryParams['currency_code'] = self.apiClient.toPathValue(params['currency_code'])
        if ('order_date' in params):
            queryParams['order_date'] = self.apiClient.toPathValue(params['order_date'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'calculateSimpleTaxOut')
        return responseObject
        

        

    def validateTaxNumber(self, tax_number, **kwargs):
        """Validate VAT number

        Args:
            country_code, str: Two-letter ISO country code. (optional)

            tax_number, str: Tax number (required)

            

        Returns: validateTaxNumberOut
        """

        allParams = ['country_code', 'tax_number']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method validateTaxNumber" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/tax/vat_numbers/{tax_number}/validate'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('country_code' in params):
            queryParams['country_code'] = self.apiClient.toPathValue(params['country_code'])
        if ('tax_number' in params):
            replacement = str(self.apiClient.toPathValue(params['tax_number']))
            resourcePath = resourcePath.replace('{' + 'tax_number' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'validateTaxNumberOut')
        return responseObject
        

        

    def calculateTaxLocation(self, **kwargs):
        """Calculate location

        Args:
            billing_country_code, str: Billing two letter ISO country code. (optional)

            buyer_credit_card_prefix, str: Buyer's credit card prefix. (optional)

            

        Returns: calculateTaxLocationOut
        """

        allParams = ['billing_country_code', 'buyer_credit_card_prefix']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method calculateTaxLocation" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/tax/location/calculate'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('billing_country_code' in params):
            queryParams['billing_country_code'] = self.apiClient.toPathValue(params['billing_country_code'])
        if ('buyer_credit_card_prefix' in params):
            queryParams['buyer_credit_card_prefix'] = self.apiClient.toPathValue(params['buyer_credit_card_prefix'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'calculateTaxLocationOut')
        return responseObject
        

        

    def locateMyIP(self, **kwargs):
        """Locate IP

        Args:
            

        Returns: locateMyIPOut
        """

        allParams = []

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method locateMyIP" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/geoip'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'locateMyIPOut')
        return responseObject
        

        

    def locateGivenIP(self, ip, **kwargs):
        """Locate provided IP

        Args:
            ip, str: IP address. (optional)

            

        Returns: locateGivenIPOut
        """

        allParams = ['ip']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method locateGivenIP" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/geoip/{ip}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('ip' in params):
            replacement = str(self.apiClient.toPathValue(params['ip']))
            resourcePath = resourcePath.replace('{' + 'ip' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'locateGivenIPOut')
        return responseObject
        

        

    def getTransactionsStats(self, date_from, date_to, **kwargs):
        """Transaction stats

        Args:
            date_from, str: Date from in yyyy-MM format. (required)

            date_to, str: Date to in yyyy-MM format. (required)

            interval, str: Interval. Accepted values are 'day', 'week' and 'month'. (optional)

            

        Returns: getTransactionsStatsOut
        """

        allParams = ['date_from', 'date_to', 'interval']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getTransactionsStats" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/stats/transactions'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('date_from' in params):
            queryParams['date_from'] = self.apiClient.toPathValue(params['date_from'])
        if ('date_to' in params):
            queryParams['date_to'] = self.apiClient.toPathValue(params['date_to'])
        if ('interval' in params):
            queryParams['interval'] = self.apiClient.toPathValue(params['interval'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getTransactionsStatsOut')
        return responseObject
        

        

    def getSettlementStatsByCountry(self, date_from, date_to, **kwargs):
        """Settlement stats per country

        Args:
            date_from, str: Date from in yyyy-MM format. (required)

            date_to, str: Date to in yyyy-MM format. (required)

            

        Returns: getSettlementStatsByCountryOut
        """

        allParams = ['date_from', 'date_to']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getSettlementStatsByCountry" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/stats/settlement/by_country'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('date_from' in params):
            queryParams['date_from'] = self.apiClient.toPathValue(params['date_from'])
        if ('date_to' in params):
            queryParams['date_to'] = self.apiClient.toPathValue(params['date_to'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getSettlementStatsByCountryOut')
        return responseObject
        

        

    def getSettlementStatsByTaxationType(self, date_from, date_to, **kwargs):
        """Settlement stats per taxation type

        Args:
            date_from, str: Date from in yyyy-MM format. (required)

            date_to, str: Date to in yyyy-MM format. (required)

            

        Returns: getSettlementStatsByTaxationTypeOut
        """

        allParams = ['date_from', 'date_to']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getSettlementStatsByTaxationType" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/stats/settlement/by_taxation_type'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('date_from' in params):
            queryParams['date_from'] = self.apiClient.toPathValue(params['date_from'])
        if ('date_to' in params):
            queryParams['date_to'] = self.apiClient.toPathValue(params['date_to'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getSettlementStatsByTaxationTypeOut')
        return responseObject
        

        

    def getDailySettlementStats(self, interval, date_from, date_to, **kwargs):
        """Settlement stats over time

        Args:
            interval, str: Interval type - day, week, month. (required)

            date_from, str: Date from in yyyy-MM format. (required)

            date_to, str: Date to in yyyy-MM format. (required)

            

        Returns: getDailySettlementStatsOut
        """

        allParams = ['interval', 'date_from', 'date_to']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getDailySettlementStats" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/stats/settlement/daily'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('interval' in params):
            queryParams['interval'] = self.apiClient.toPathValue(params['interval'])
        if ('date_from' in params):
            queryParams['date_from'] = self.apiClient.toPathValue(params['date_from'])
        if ('date_to' in params):
            queryParams['date_to'] = self.apiClient.toPathValue(params['date_to'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getDailySettlementStatsOut')
        return responseObject
        

        

    def getRefunds(self, **kwargs):
        """Fetch refunds

        Args:
            moss_country_code, str: MOSS country code, used to determine currency. If ommited, merchant default setting is used. (optional)

            date_from, str: Take only refunds issued at or after the date. Format: yyyy-MM-dd (optional)

            

        Returns: getRefundsOut
        """

        allParams = ['moss_country_code', 'date_from']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getRefunds" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/settlement/refunds'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('moss_country_code' in params):
            queryParams['moss_country_code'] = self.apiClient.toPathValue(params['moss_country_code'])
        if ('date_from' in params):
            queryParams['date_from'] = self.apiClient.toPathValue(params['date_from'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getRefundsOut')
        return responseObject
        

        

    def getSettlement(self, quarter, **kwargs):
        """Fetch settlement

        Args:
            format, str: Output format. 'csv' value is accepted as well (optional)

            moss_country_code, str: MOSS country code, used to determine currency. If ommited, merchant default setting is used. (optional)

            quarter, str: Quarter in yyyy-MM format. (required)

            

        Returns: getSettlementOut
        """

        allParams = ['format', 'moss_country_code', 'quarter']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getSettlement" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/settlement/{quarter}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('format' in params):
            queryParams['format'] = self.apiClient.toPathValue(params['format'])
        if ('moss_country_code' in params):
            queryParams['moss_country_code'] = self.apiClient.toPathValue(params['moss_country_code'])
        if ('quarter' in params):
            replacement = str(self.apiClient.toPathValue(params['quarter']))
            resourcePath = resourcePath.replace('{' + 'quarter' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getSettlementOut')
        return responseObject
        

        

    def getSettlementSummary(self, quarter, **kwargs):
        """Fetch settlement summary

        Args:
            moss_country_code, str: MOSS country code, used to determine currency. If ommited, merchant default setting is used. (optional)

            quarter, str: Quarter in yyyy-MM format. (required)

            

        Returns: getSettlementSummaryOut
        """

        allParams = ['moss_country_code', 'quarter']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getSettlementSummary" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/settlement/summary/{quarter}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('moss_country_code' in params):
            queryParams['moss_country_code'] = self.apiClient.toPathValue(params['moss_country_code'])
        if ('quarter' in params):
            replacement = str(self.apiClient.toPathValue(params['quarter']))
            resourcePath = resourcePath.replace('{' + 'quarter' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getSettlementSummaryOut')
        return responseObject
        

        

    def createSMSToken(self, body, **kwargs):
        """Create SMS token

        Args:
            body, createSMSTokenIn: Input (required)

            

        Returns: createSMSTokenOut
        """

        allParams = ['body']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method createSMSToken" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/verification/sms'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'POST'

        queryParams = {}
        headerParams = {}

        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'createSMSTokenOut')
        return responseObject
        

        

    def verifySMSToken(self, token, **kwargs):
        """Verify SMS token

        Args:
            token, str: Provided token. (required)

            

        Returns: verifySMSTokenOut
        """

        allParams = ['token']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method verifySMSToken" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/verification/sms/{token}'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('token' in params):
            replacement = str(self.apiClient.toPathValue(params['token']))
            resourcePath = resourcePath.replace('{' + 'token' + '}',
                                                replacement)
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'verifySMSTokenOut')
        return responseObject
        

        

    def getCurrenciesDict(self, **kwargs):
        """Currencies

        Args:
            

        Returns: getCurrenciesDictOut
        """

        allParams = []

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getCurrenciesDict" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/dictionaries/currencies'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getCurrenciesDictOut')
        return responseObject
        

        

    def getProductTypesDict(self, **kwargs):
        """Product types

        Args:
            

        Returns: getProductTypesDictOut
        """

        allParams = []

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getProductTypesDict" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/dictionaries/product_types'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getProductTypesDictOut')
        return responseObject
        

        

    def getCountriesDict(self, **kwargs):
        """Countries

        Args:
            tax_supported, bool: Should only countries with tax supported be listed? (optional)

            

        Returns: getCountriesDictOut
        """

        allParams = ['tax_supported']

        params = locals()
        for (key, val) in params['kwargs'].iteritems():
            if key not in allParams:
                raise TypeError("Got an unexpected keyword argument '%s' to method getCountriesDict" % key)
            params[key] = val
        del params['kwargs']

        resourcePath = '/api/v1/dictionaries/countries'
        resourcePath = resourcePath.replace('{format}', 'json')
        method = 'GET'

        queryParams = {}
        headerParams = {}

        if ('tax_supported' in params):
            queryParams['tax_supported'] = self.apiClient.toPathValue(params['tax_supported'])
        postData = (params['body'] if 'body' in params else None)

        response = self.apiClient.callAPI(resourcePath, method, queryParams,
                                          postData, headerParams)

        if not response:
            return None

        responseObject = self.apiClient.deserialize(response, 'getCountriesDictOut')
        return responseObject
        

        

    




